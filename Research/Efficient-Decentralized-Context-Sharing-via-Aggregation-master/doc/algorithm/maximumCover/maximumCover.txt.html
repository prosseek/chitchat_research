<h1 id="maximum-cover-algorithm">Maximum Cover algorithm</h1>
<h2 id="problem-definition">Problem definition</h2>
<p>When we have five aggregates (a-e) that has a subset of singles universe(1-7), how can we find the set of aggregates that covers most in the universe.</p>
<p>For example, in this input.</p>
<pre><code>  12345678
a XX
b  XXX
c   XXX  X
d     XXX
e       XX</code></pre>
<p>We find that [c,a] will give us the maximum coverage of the universe.</p>
<h2 id="algorithm">Algorithm</h2>
<h3 id="friends-and-enemies">friends and enemies</h3>
<p>Let's define friends of an aggregate as a set of aggregates that doesn't share elements. For example, 'a' and 'c','d','e' are friends, whereas 'b' is an enemy.</p>
<h3 id="ideas">Ideas</h3>
<ol style="list-style-type: decimal">
<li>The idea starts with selecting the aggregate that has the maximum element. In this example, 'c' is selected.</li>
<li>A set of solution is collected as we iterate (recurse). For the first case, we have ['c'] as a solution.</li>
<li>When we select a set of friends among which the next solution is selected. 'c' has single friend 'a'.</li>
<li>We also amass the set of enemies. The enemies are a set of enemies from the solution, and the solution itself is a part of enemy. After we get the friend set, we remove enemies from the friends.</li>
</ol>
<h3 id="example">Example</h3>
<ol style="list-style-type: decimal">
<li>'c' has the maximum number of elements, so 'c' is included in the solution:[c]</li>
<li>'c' has a friend 'a', and enemies of [b,d,e] + 'c', and remove enemies from friend, and we get a new friend set [a]</li>
<li>we recursively call solve() method with friend([a]), and enemy([b,c,d,e])</li>
<li>a is added to solution ([c,a])</li>
<li>a has friend [c,d,e], however all of them are in enemy set, so a has no friend.</li>
<li>Return the solution ([c,a])</li>
</ol>
